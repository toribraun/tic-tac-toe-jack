class Board {
    field Array boardArray;
    field int boardX, boardY, boardSize, boardPixelSize, lineThickness, cellPixelSize;
    field int totalCellCount, freeCellCount;
    field int signSize;

    constructor Board new(int size) {		
        let boardX = 200;
        let boardY = 60;
		let boardSize = size;
		let boardPixelSize = 120;
		let lineThickness = 2;
		let cellPixelSize = boardPixelSize/size;
        let signSize = cellPixelSize/2;
        let totalCellCount = size*size;
		let boardArray = Array.new(totalCellCount);
        do clearBoard();
		return this;
	}

    method void dispose() {
		do Screen.setColor(false);
		do Screen.drawRectangle(boardX, boardY, boardX+boardPixelSize, boardY+boardPixelSize);
		do Screen.setColor(true);
		do Memory.deAlloc(boardArray);
		return;
	}
	
	method void clearBoard() {
		var int i;
		let freeCellCount = totalCellCount;
		while(i<totalCellCount) {
			let boardArray[i] = false;
			let i = i + 1;
		}
		return;
	}

	method void drawBoard() {
		var int offset;
        var int i;
		let offset = lineThickness/2;
        let i = 1;

        while(i<boardSize) {
            // draw vertical line
		    do Screen.drawRectangle(boardX+(i*cellPixelSize)-offset,boardY, boardX+(i*cellPixelSize)+offset,boardY+boardPixelSize);
            do Number.drawNumber(i, boardX + (i*cellPixelSize) - (cellPixelSize/2), boardY - 24);

            // draw horizontal lines
            do Screen.drawRectangle(boardX,boardY+(i*cellPixelSize)-offset, boardX+boardPixelSize,boardY+(i*cellPixelSize)+offset);
            do Number.drawNumber(i, boardX - 24, boardY + ((i-1)*cellPixelSize) + (cellPixelSize/2));

			let i = i + 1;
		}
        
        do Number.drawNumber(i, boardX + (i*cellPixelSize) - (cellPixelSize/2), boardY - 24);
        do Number.drawNumber(i, boardX - 24, boardY + ((i-1)*cellPixelSize) + (cellPixelSize/2));

		return;
	}

    method boolean drawMove(int row, int col, boolean isCross) {
		var int xl, yt;

        let row = row - 1;
        let col = col - 1;

        if(~isCellFree(row, col)) {
			return false;
		} 

		let xl = colToX(col) + ((cellPixelSize-signSize)/2);
		let yt = rowToY(row) + ((cellPixelSize-signSize)/2);
        if (isCross) {
            do drawCross(xl,yt);
        } else {
            do drawZero(xl,yt);
        }

        let boardArray[row*boardSize+col] = true;
        let freeCellCount = freeCellCount - 1;

		return true;
	}

	method int rowToY(int r) {
		return boardY + (r*cellPixelSize);
	}
	
	method int colToX(int c) {
		return boardX + (c*cellPixelSize);
	}

	method void drawCross(int x, int y) {
		do Screen.drawLine(x,y+signSize,x+signSize,y);
		do Screen.drawLine(x,y+signSize,x+signSize,y);
			
		do Screen.drawLine(x,y,x+signSize,y+signSize);
		do Screen.drawLine(x,y,x+signSize,y+signSize);
	
		return;
	}

	method void drawZero(int x, int y) {
		var int rOut,rIn;
		let rOut = signSize/2;
		let rIn = rOut-lineThickness;
		
		do Screen.drawCircle(x+rOut,y+rOut,rOut);
		do Screen.setColor(false);
		do Screen.drawCircle(x+rOut,y+rOut,rIn);
		do Screen.setColor(true);
		return;
	}   

	method boolean isCellFree(int row, int col) {
		return ~boardArray[row*boardSize+col];
	}

}